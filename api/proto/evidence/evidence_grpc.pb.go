// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.2
// source: evidence/evidence.proto

package evidencepb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EvidenceService_ListEvidence_FullMethodName  = "/evidencepb.EvidenceService/ListEvidence"
	EvidenceService_GetEvidence_FullMethodName   = "/evidencepb.EvidenceService/GetEvidence"
	EvidenceService_ListLocations_FullMethodName = "/evidencepb.EvidenceService/ListLocations"
)

// EvidenceServiceClient is the client API for EvidenceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EvidenceServiceClient interface {
	ListEvidence(ctx context.Context, in *ListEvidenceRequest, opts ...grpc.CallOption) (*EvidenceList, error)
	GetEvidence(ctx context.Context, in *GetEvidenceRequest, opts ...grpc.CallOption) (*Evidence, error)
	ListLocations(ctx context.Context, in *ListLocationsRequest, opts ...grpc.CallOption) (*LocationList, error)
}

type evidenceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEvidenceServiceClient(cc grpc.ClientConnInterface) EvidenceServiceClient {
	return &evidenceServiceClient{cc}
}

func (c *evidenceServiceClient) ListEvidence(ctx context.Context, in *ListEvidenceRequest, opts ...grpc.CallOption) (*EvidenceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvidenceList)
	err := c.cc.Invoke(ctx, EvidenceService_ListEvidence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evidenceServiceClient) GetEvidence(ctx context.Context, in *GetEvidenceRequest, opts ...grpc.CallOption) (*Evidence, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Evidence)
	err := c.cc.Invoke(ctx, EvidenceService_GetEvidence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evidenceServiceClient) ListLocations(ctx context.Context, in *ListLocationsRequest, opts ...grpc.CallOption) (*LocationList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocationList)
	err := c.cc.Invoke(ctx, EvidenceService_ListLocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvidenceServiceServer is the server API for EvidenceService service.
// All implementations must embed UnimplementedEvidenceServiceServer
// for forward compatibility.
type EvidenceServiceServer interface {
	ListEvidence(context.Context, *ListEvidenceRequest) (*EvidenceList, error)
	GetEvidence(context.Context, *GetEvidenceRequest) (*Evidence, error)
	ListLocations(context.Context, *ListLocationsRequest) (*LocationList, error)
	mustEmbedUnimplementedEvidenceServiceServer()
}

// UnimplementedEvidenceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEvidenceServiceServer struct{}

func (UnimplementedEvidenceServiceServer) ListEvidence(context.Context, *ListEvidenceRequest) (*EvidenceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvidence not implemented")
}
func (UnimplementedEvidenceServiceServer) GetEvidence(context.Context, *GetEvidenceRequest) (*Evidence, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvidence not implemented")
}
func (UnimplementedEvidenceServiceServer) ListLocations(context.Context, *ListLocationsRequest) (*LocationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocations not implemented")
}
func (UnimplementedEvidenceServiceServer) mustEmbedUnimplementedEvidenceServiceServer() {}
func (UnimplementedEvidenceServiceServer) testEmbeddedByValue()                         {}

// UnsafeEvidenceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EvidenceServiceServer will
// result in compilation errors.
type UnsafeEvidenceServiceServer interface {
	mustEmbedUnimplementedEvidenceServiceServer()
}

func RegisterEvidenceServiceServer(s grpc.ServiceRegistrar, srv EvidenceServiceServer) {
	// If the following call pancis, it indicates UnimplementedEvidenceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EvidenceService_ServiceDesc, srv)
}

func _EvidenceService_ListEvidence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEvidenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvidenceServiceServer).ListEvidence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvidenceService_ListEvidence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvidenceServiceServer).ListEvidence(ctx, req.(*ListEvidenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvidenceService_GetEvidence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvidenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvidenceServiceServer).GetEvidence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvidenceService_GetEvidence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvidenceServiceServer).GetEvidence(ctx, req.(*GetEvidenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvidenceService_ListLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvidenceServiceServer).ListLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvidenceService_ListLocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvidenceServiceServer).ListLocations(ctx, req.(*ListLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EvidenceService_ServiceDesc is the grpc.ServiceDesc for EvidenceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EvidenceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "evidencepb.EvidenceService",
	HandlerType: (*EvidenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListEvidence",
			Handler:    _EvidenceService_ListEvidence_Handler,
		},
		{
			MethodName: "GetEvidence",
			Handler:    _EvidenceService_GetEvidence_Handler,
		},
		{
			MethodName: "ListLocations",
			Handler:    _EvidenceService_ListLocations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evidence/evidence.proto",
}

const (
	CSIService_AnalyzeEvidence_FullMethodName = "/evidencepb.CSIService/AnalyzeEvidence"
)

// CSIServiceClient is the client API for CSIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CSIServiceClient interface {
	AnalyzeEvidence(ctx context.Context, in *AnalyzeEvidenceRequest, opts ...grpc.CallOption) (*AnalysisResult, error)
}

type cSIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCSIServiceClient(cc grpc.ClientConnInterface) CSIServiceClient {
	return &cSIServiceClient{cc}
}

func (c *cSIServiceClient) AnalyzeEvidence(ctx context.Context, in *AnalyzeEvidenceRequest, opts ...grpc.CallOption) (*AnalysisResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalysisResult)
	err := c.cc.Invoke(ctx, CSIService_AnalyzeEvidence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CSIServiceServer is the server API for CSIService service.
// All implementations must embed UnimplementedCSIServiceServer
// for forward compatibility.
type CSIServiceServer interface {
	AnalyzeEvidence(context.Context, *AnalyzeEvidenceRequest) (*AnalysisResult, error)
	mustEmbedUnimplementedCSIServiceServer()
}

// UnimplementedCSIServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCSIServiceServer struct{}

func (UnimplementedCSIServiceServer) AnalyzeEvidence(context.Context, *AnalyzeEvidenceRequest) (*AnalysisResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeEvidence not implemented")
}
func (UnimplementedCSIServiceServer) mustEmbedUnimplementedCSIServiceServer() {}
func (UnimplementedCSIServiceServer) testEmbeddedByValue()                    {}

// UnsafeCSIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CSIServiceServer will
// result in compilation errors.
type UnsafeCSIServiceServer interface {
	mustEmbedUnimplementedCSIServiceServer()
}

func RegisterCSIServiceServer(s grpc.ServiceRegistrar, srv CSIServiceServer) {
	// If the following call pancis, it indicates UnimplementedCSIServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CSIService_ServiceDesc, srv)
}

func _CSIService_AnalyzeEvidence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeEvidenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CSIServiceServer).AnalyzeEvidence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CSIService_AnalyzeEvidence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CSIServiceServer).AnalyzeEvidence(ctx, req.(*AnalyzeEvidenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CSIService_ServiceDesc is the grpc.ServiceDesc for CSIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CSIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "evidencepb.CSIService",
	HandlerType: (*CSIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnalyzeEvidence",
			Handler:    _CSIService_AnalyzeEvidence_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evidence/evidence.proto",
}
